---
title: 工作者线程
---
<big>作者： chenglNG(yuanchenglang)</big>

<big>时间：2021年1月11日 2021-01-11 07:58:54</big>

# 工作者线程

javascript单线程语言，POSIX线程或java的Thread类等传统并发结构不适合javascript，假如javascript可以多线程执行并发更改，那么像DOM这样的API就会出现问题。这也是工作者线程的价值所在：允许主线程工作转嫁给独立结构的实体，而不改变单线程模型，共同点都是创建一个完全独立的全局上下文（开销有点大），独立于javascript的主执行环境。

## 专用工作者线程

顾名思义，就是只能被创建它的页面使用的线程。有几个要注意的地方：
### 安全限制
只能从父页面相同的源加载，从其他源加载会导致错误。
### 生命周期 
会伴随着页面整个生命周期存在，除非通过自我终止（self.cose()）或者外部终止（worker.terminate()）
### 内部终止
调用了close()，工作者线程没有立即终止，只是取消了时间循环中的所有任务，并组织继续添加任务。

```js
//closeWorker.js
self.postMessage('foo1')
self.close()
self.postMessage('foo2')
setTimeout(() => {
  self.postMessage('foo3')
})

//main.js
const worker  = new Worker('./Wokrer.js')
worker.message = function({data}) {
  console.log(data)
}
// 结果
// foo1
// foo2
```
### 外部导入模块

使用importScript,可以请求任何源的脚本，类似于生成script标签动态加载脚本，导入的脚本会共享作用域。

```js
// scriptA.js
console.log(`${number}`)
// scriptB.js
console.log(`${number}`)

// main.js
const numner = 100
importScript('./scriptA.js', './scriptB.js')

// 结果
// 100
// 100
```

### 创建线程

#### 一般创建
```js
//closeWorker.js
self.postMessage('foo')

//main.js
const worker  = new Worker('./Wokrer.js')
worker.message = function({data}) {
  console.log(data)
}
```
#### 在javascript行内创建

更新中...

## 共享工作者线程

安全限制和专用工作者线程一样，可以同时被多个执行上下文访问，例如：同源的两个不同的页面访问同一个共享线程。可以数据传递性能开销。

## 特点
无论导入多少次同一个脚本（这里有点讲究），只会加载一个共享线程。

## 服务工作者线程
服务工作者线程也是一种工作者线程，但他们更像网络代理，而非独立的浏览器线程。可以把他们看成是高度定制化的网络缓存，也支持，在PWA中支持推送通知。

更新中...

## 线程间通信

更新中...
